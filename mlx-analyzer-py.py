"""
MLX computation module for data storytelling.

This module implements functions for performing secondary calculations using MLX
to enhance the narrative generated by the data storyteller agent.
"""

import mlx.core as mx
from typing import Tuple, List, Union

# Local imports
from config import get_value


def calculate_percentage_change(new_values: mx.array, baseline: float) -> mx.array:
    """
    Calculate percentage change between new values and a baseline value.
    
    This calculation is useful for storytelling by quantifying the relative change
    in metrics, allowing stakeholders to understand the magnitude of impact.
    
    Args:
        new_values: MLX array of new values
        baseline: Baseline value for comparison
        
    Returns:
        MLX array of percentage changes
    """
    baseline_array = mx.array(baseline)
    change = mx.subtract(new_values, baseline_array)
    percentage_change = mx.multiply(mx.divide(change, baseline_array), 100.0)
    return percentage_change


def find_max_impact_segment(values: mx.array) -> Tuple[int, float]:
    """
    Find the segment with the maximum impact.
    
    This calculation is useful for storytelling by identifying the standout performer
    or most affected segment, allowing the narrative to highlight the most impactful area.
    
    Args:
        values: MLX array of impact values per segment
        
    Returns:
        Tuple of (index of max value, max value)
    """
    max_index = mx.argmax(values)
    max_value = values[max_index]
    return max_index, max_value


def calculate_difference_from_mean(values: mx.array) -> mx.array:
    """
    Calculate the difference of each value from the mean.
    
    This calculation is useful for storytelling by providing context on how each segment
    compares to the average, enabling the narrative to highlight over/underperformers.
    
    Args:
        values: MLX array of values
        
    Returns:
        MLX array of differences from the mean
    """
    mean_value = mx.mean(values)
    differences = mx.subtract(values, mean_value)
    return differences


def calculate_contribution_percentage(values: mx.array) -> mx.array:
    """
    Calculate the percentage contribution of each value to the total.
    
    This calculation is useful for storytelling by showing the relative importance
    of different segments or channels, enabling the narrative to highlight key contributors.
    
    Args:
        values: MLX array of values
        
    Returns:
        MLX array of contribution percentages
    """
    total = mx.sum(values)
    contributions = mx.multiply(mx.divide(values, total), 100.0)
    return contributions


def calculate_rolling_average(values: mx.array, window_size: int = None) -> mx.array:
    """
    Calculate rolling averages to smooth time-series data.
    
    This calculation is useful for storytelling by revealing underlying trends
    in noisy data, enabling the narrative to focus on meaningful patterns.
    
    Args:
        values: MLX array of time-series values
        window_size: Size of the rolling window (uses config if not provided)
        
    Returns:
        MLX array of rolling averages
    """
    # Use the provided window size or get from config
    if window_size is None:
        window_size = get_value("mlx.rolling_window_size", 3)
        
    n = len(values)
    result = mx.zeros(n - window_size + 1)
    
    for i in range(n - window_size + 1):
        window = values[i:i+window_size]
        result[i] = mx.mean(window)
    
    return result


def calculate_trend_significance(values: mx.array, min_data_points: int = None) -> float:
    """
    Calculate the statistical significance of a trend in the data.
    
    This calculation helps determine if an observed trend is statistically
    significant, providing confidence in the narrative's trend statements.
    
    Args:
        values: MLX array of time-series values
        min_data_points: Minimum number of data points required (uses config if not provided)
        
    Returns:
        Significance score (0-1) where higher values indicate more significant trends
    """
    # Use the provided minimum or get from config
    if min_data_points is None:
        min_data_points = get_value("mlx.min_data_points", 10)
        
    # If we don't have enough data points, return low significance
    if len(values) < min_data_points:
        return 0.5  # Medium significance
    
    # Create indices for the x-axis (time)
    indices = mx.array(range(len(values)))
    
    # Calculate means
    mean_x = mx.mean(indices)
    mean_y = mx.mean(values)
    
    # Calculate variances and covariance
    var_x = mx.mean(mx.power(mx.subtract(indices, mean_x), 2))
    covar_xy = mx.mean(mx.multiply(
        mx.subtract(indices, mean_x),
        mx.subtract(values, mean_y)
    ))
    
    # Calculate slope and r-squared
    if var_x > 0:
        slope = covar_xy / var_x
        # Calculate predicted values
        predicted = mean_y + slope * (indices - mean_x)
        # Calculate total sum of squares and residual sum of squares
        ss_total = mx.sum(mx.power(mx.subtract(values, mean_y), 2))
        ss_residual = mx.sum(mx.power(mx.subtract(values, predicted), 2))
        
        if ss_total > 0:
            r_squared = 1 - (ss_residual / ss_total)
            return float(r_squared)  # Convert to Python float
            
    return 0.0  # Default significance if calculation fails


def filter_data_by_confidence(values: mx.array, confidences: mx.array) -> mx.array:
    """
    Filter data points based on their confidence scores.
    
    This function helps focus the narrative on high-confidence insights
    by filtering out data points with low confidence.
    
    Args:
        values: MLX array of values
        confidences: MLX array of confidence scores for each value
        
    Returns:
        MLX array of values where confidence exceeds threshold
    """
    # Get confidence threshold from config
    threshold = get_value("mlx.confidence_threshold", 0.7)
    
    # Create mask for values with confidence above threshold
    mask = confidences >= threshold
    
    # Return filtered values
    return values[mask]
